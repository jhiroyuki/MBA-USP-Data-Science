obs = n())
## 'Family_Size'
group_by(segmenta, cluster_K) %>%
summarise(
mean = mean(Family_Size, na.rm = TRUE),
sd = sd(Family_Size, na.rm = TRUE),
min = min(Family_Size, na.rm = TRUE),
max = max(Family_Size, na.rm = TRUE),
obs = n())
## 'Gender'
group_by(segmenta, cluster_K) %>%
count(Gender) %>%
mutate(prop = prop.table(n))
## 'Ever_Maried'
group_by(segmenta, cluster_K) %>%
count(Ever_Married) %>%
mutate(prop = prop.table(n))
## 'Graduated'
group_by(segmenta, cluster_K) %>%
count(Graduated) %>%
mutate(prop = prop.table(n))
## 'Spending_Score'
group_by(segmenta, cluster_K) %>%
count(Spending_Score) %>%
mutate(prop = prop.table(n))
# Vamos gerar a ACM (para 3 eixos)
ACM <- dudi.acm(segmenta_quali, scannf = FALSE, nf = 3)
# Analisando as variâncias de cada dimensão
perc_variancia <- (ACM$eig / sum(ACM$eig)) * 100
perc_variancia
# Quantidade de categorias por variável
quant_categorias <- apply(segmenta_quali,
MARGIN =  2,
FUN = function(x) nlevels(as.factor(x)))
# Consolidando as coordenadas-padrão obtidas por meio da matriz binária
df_ACM <- data.frame(ACM$c1, Variável = rep(names(quant_categorias),
quant_categorias))
# Plotando o mapa perceptual
df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Variável)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(x = paste("Dimensão 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimensão 2:", paste0(round(perc_variancia[2], 2), "%"))) +
theme_bw()
# Mapa perceptual em 3D (3 primeiras dimensões)
ACM_3D <- plot_ly()
# Adicionando as coordenadas
ACM_3D <- add_trace(p = ACM_3D,
x = df_ACM$CS1,
y = df_ACM$CS2,
z = df_ACM$CS3,
mode = "text",
text = rownames(df_ACM),
textfont = list(color = "blue"),
marker = list(color = "red"),
showlegend = FALSE)
ACM_3D
# Plotando o mapa perceptual
df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Variável)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(x = paste("Dimensão 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimensão 2:", paste0(round(perc_variancia[2], 2), "%"))) +
theme_bw()
gc()
pacotes <- c("plotly",
"tidyverse",
"ggrepel",
"knitr",
"kableExtra",
"reshape2",
"PerformanceAnalytics",
"psych",
"ltm",
"Hmisc",
"readxl",
"sjPlot",
"ade4")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# Carregamento da base de dados
casas <- read_xlsx("Preco Casas.xlsx")
var_quali
# Separação das variáveis em qualitativas e quantitativas
var_quali <- casas[,c(5,6,7,8,10,12,15)]
var_quanti <- casas[,c(1,2,3,4,9,11,13,14)]
# Tabelas de contingência
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$parking_space,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$front_garden,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$swimming_pool,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$wall_fence,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$water_front,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$room_size_class,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
# Análise de Correspondência Múltipla
ACM <- dudi.acm(var_quali, scannf = FALSE)
# Analisando as variâncias de cada dimensão
perc_variancia <- (ACM$eig / sum(ACM$eig)) * 100
perc_variancia
# Quantidade de categorias por variável
quant_categorias <- apply(var_quali,
MARGIN =  2,
FUN = function(x) nlevels(as.factor(x)))
# Consolidando as coordenadas-padrão obtidas por meio da matriz binária
df_ACM <- data.frame(ACM$c1, Variável = rep(names(quant_categorias),
quant_categorias))
# Plotando o mapa perceptual
df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Variável)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(x = paste("Dimensão 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimensão 2:", paste0(round(perc_variancia[2], 2), "%"))) +
theme_bw()
# Plotando o mapa perceptual
df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Variável)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(x = paste("Dimensão 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimensão 2:", paste0(round(perc_variancia[2], 2), "%"))) +
theme_bw()
pacotes <- c("plotly",
"tidyverse",
"ggrepel",
"knitr",
"kableExtra",
"reshape2",
"PerformanceAnalytics",
"psych",
"ltm",
"Hmisc",
"readxl",
"sjPlot",
"ade4")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# Carregamento da base de dados
casas <- read_xlsx("Preco Casas.xlsx")
# Separação das variáveis em qualitativas e quantitativas
var_quali <- casas[,c(5,6,7,8,10,12,15)]
var_quanti <- casas[,c(1,2,3,4,9,11,13,14)]
# A função para a criação da ACM pede que sejam utilizados "fatores"
var_quali <- as.data.frame(unclass(var_quali), stringsAsFactors=TRUE)
# Ajustando variáveis quantitativas que estão como textos
var_quanti$distance_to_school <- as.double(var_quanti$distance_to_school)
var_quanti$distance_to_supermarket_km <- as.double(var_quanti$distance_to_supermarket_km)
var_quanti$crime_rate_index <- as.double(var_quanti$crime_rate_index)
# Estatísticas descritivas
summary(var_quali)
summary(var_quanti)
# Tabelas de contingência
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$parking_space,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$front_garden,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$swimming_pool,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$wall_fence,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$water_front,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$room_size_class,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
# Análise de Correspondência Múltipla
ACM <- dudi.acm(var_quali, scannf = FALSE)
# Analisando as variâncias de cada dimensão
perc_variancia <- (ACM$eig / sum(ACM$eig)) * 100
perc_variancia
# Quantidade de categorias por variável
quant_categorias <- apply(var_quali,
MARGIN =  2,
FUN = function(x) nlevels(as.factor(x)))
# Consolidando as coordenadas-padrão obtidas por meio da matriz binária
df_ACM <- data.frame(ACM$c1, Variável = rep(names(quant_categorias),
quant_categorias))
# Plotando o mapa perceptual
df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Variável)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(x = paste("Dimensão 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimensão 2:", paste0(round(perc_variancia[2], 2), "%"))) +
theme_bw()
# Obtendo as coordenadas das observações
coord_obs <- ACM$li
View(ACM)
# Análise de Correspondência Múltipla
ACM <- dudi.acm(var_quali, scannf = FALSE)
# Analisando as variâncias de cada dimensão
perc_variancia <- (ACM$eig / sum(ACM$eig)) * 100
perc_variancia
# Quantidade de categorias por variável
quant_categorias <- apply(var_quali,
MARGIN =  2,
FUN = function(x) nlevels(as.factor(x)))
# Consolidando as coordenadas-padrão obtidas por meio da matriz binária
df_ACM <- data.frame(ACM$c1, Variável = rep(names(quant_categorias),
quant_categorias))
# Plotando o mapa perceptual
df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Variável)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(x = paste("Dimensão 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimensão 2:", paste0(round(perc_variancia[2], 2), "%"))) +
theme_bw()
# Obtendo as coordenadas das observações
coord_obs <- ACM$li
# Adicionando as coordenadas ao banco de dados de variáveis quantitativas
var_quanti <- bind_cols(var_quanti, coord_obs)
View(var_quanti)
View(coord_obs)
# Adicionando as coordenadas ao banco de dados de variáveis quantitativas
# Adicionando as coordenadas ao banco de dados de variáveis quantitativas
var_quanti <- bind_cols(var_quanti, coord_obs)
View(var_quanti)
pacotes <- c("plotly",
"tidyverse",
"ggrepel",
"knitr",
"kableExtra",
"reshape2",
"PerformanceAnalytics",
"psych",
"ltm",
"Hmisc",
"readxl",
"sjPlot",
"ade4")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# Carregamento da base de dados
casas <- read_xlsx("Preco Casas.xlsx")
# Separação das variáveis em qualitativas e quantitativas
var_quali <- casas[,c(5,6,7,8,10,12,15)]
var_quanti <- casas[,c(1,2,3,4,9,11,13,14)]
# A função para a criação da ACM pede que sejam utilizados "fatores"
var_quali <- as.data.frame(unclass(var_quali), stringsAsFactors=TRUE)
# Ajustando variáveis quantitativas que estão como textos
var_quanti$distance_to_school <- as.double(var_quanti$distance_to_school)
var_quanti$distance_to_supermarket_km <- as.double(var_quanti$distance_to_supermarket_km)
var_quanti$crime_rate_index <- as.double(var_quanti$crime_rate_index)
# Estatísticas descritivas
summary(var_quali)
summary(var_quanti)
# Tabelas de contingência
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$parking_space,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$front_garden,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$swimming_pool,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$wall_fence,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$water_front,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = var_quali$large_living_room,
var.col = var_quali$room_size_class,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
# Análise de Correspondência Múltipla
ACM <- dudi.acm(var_quali, scannf = FALSE)
# Analisando as variâncias de cada dimensão
perc_variancia <- (ACM$eig / sum(ACM$eig)) * 100
perc_variancia
# Quantidade de categorias por variável
quant_categorias <- apply(var_quali,
MARGIN =  2,
FUN = function(x) nlevels(as.factor(x)))
# Consolidando as coordenadas-padrão obtidas por meio da matriz binária
df_ACM <- data.frame(ACM$c1, Variável = rep(names(quant_categorias),
quant_categorias))
# Plotando o mapa perceptual
df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Variável)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(x = paste("Dimensão 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimensão 2:", paste0(round(perc_variancia[2], 2), "%"))) +
theme_bw()
# Obtendo as coordenadas das observações
coord_obs <- ACM$li
# Adicionando as coordenadas ao banco de dados de variáveis quantitativas
var_quanti <- bind_cols(var_quanti, coord_obs)
# Coeficientes de correlação de Pearson para cada par de variáveis
rho <- rcorr(as.matrix(var_quanti), type="pearson")
corr_coef <- rho$r # Matriz de correlações
corr_sig <- round(rho$P, 5) # Matriz com p-valor dos coeficientes
View(corr_coef)
corr_coef <- rho$r # Matriz de correlações
corr_sig <- round(rho$P, 5) # Matriz com p-valor dos coeficientes
# Elaboração de um mapa de calor das correlações de Pearson entre as variáveis
ggplotly(
var_quanti %>%
cor() %>%
melt() %>%
rename(Correlação = value) %>%
ggplot() +
geom_tile(aes(x = Var1, y = Var2, fill = Correlação)) +
geom_text(aes(x = Var1, y = Var2, label = format(round(Correlação,3))),
size = 3) +
scale_fill_viridis_b() +
labs(x = NULL, y = NULL) +
theme_bw(base_size = 6))
# Teste de esfericidade de Bartlett
cortest.bartlett(var_quanti)
# Elaboração da análise fatorial por componentes principais
fatorial <- principal(var_quanti,
nfactors = length(var_quanti),
rotate = "none",
scores = TRUE)
fatorial
# Eigenvalues (autovalores)
eigenvalues <- round(fatorial$values, 5)
eigenvalues
round(sum(eigenvalues), 2) # soma dos autovalores
# Identificação da variância compartilhada em cada fator
variancia_compartilhada <- as.data.frame(fatorial$Vaccounted) %>%
slice(1:3)
rownames(variancia_compartilhada) <- c("Autovalores",
"Prop. da Variância",
"Prop. da Variância Acumulada")
# Variância compartilhada pelas variáveis originais para a formação de cada fator
round(variancia_compartilhada, 3) %>%
kable() %>%
kable_styling(bootstrap_options = "striped",
full_width = FALSE,
font_size = 20)
# Definição da quantidade de fatores com eigenvalues maiores que 1
k <- sum(eigenvalues > 1)
print(k)
# Elaboração da análise fatorial por componentes principais
fatorial_final <- principal(var_quanti,
nfactors = k,
rotate = "none",
scores = TRUE)
# Cálculo dos scores fatoriais
scores_fatoriais <- as.data.frame(fatorial_final$weights)
# Visualização dos scores fatoriais
round(scores_fatoriais, 3) %>%
kable() %>%
kable_styling(bootstrap_options = "striped",
full_width = FALSE,
font_size = 20)
# Cálculo dos fatores propriamente ditos
fatores <- as.data.frame(fatorial_final$scores)
View(fatores)
# Cálculo das cargas fatoriais
cargas_fatoriais <- as.data.frame(unclass(fatorial_final$loadings))
# Visualização das cargas fatoriais
round(cargas_fatoriais, 3) %>%
kable() %>%
kable_styling(bootstrap_options = "striped",
full_width = FALSE,
font_size = 20)
# Cálculo das comunalidades
comunalidades <- as.data.frame(unclass(fatorial_final$communality)) %>%
rename(comunalidades = 1)
# Visualização das comunalidades para os 2 fatores extraídos
round(comunalidades, 3) %>%
kable() %>%
kable_styling(bootstrap_options = "striped",
full_width = FALSE,
font_size = 20)
# Loading plot com as cargas dos 2 primeiros fatores
cargas_fatoriais[, 1:2] %>%
data.frame() %>%
rownames_to_column("variáveis") %>%
ggplot(aes(x = PC1, y = PC2, label = variáveis)) +
geom_point(color = "darkorchid",
size = 3) +
geom_text_repel() +
geom_vline(aes(xintercept = 0), linetype = "dashed", color = "orange") +
geom_hline(aes(yintercept = 0), linetype = "dashed", color = "orange") +
expand_limits(x= c(-1.25, 0.25), y=c(-0.25, 1)) +
theme_bw()
# Criação de um ranking Critério da soma ponderada e ordenamento)
casas$ranking <- fatores$PC1 * variancia_compartilhada$PC1[2] +
fatores$PC2 * variancia_compartilhada$PC2[2] +
fatores$PC3 * variancia_compartilhada$PC3[2] +
fatores$PC4 * variancia_compartilhada$PC4[2]
# Ranking e valor
corr_valor <- rcorr(as.matrix(casas[,16:17]))
valor_corr_coef <- corr_valor$r # Matriz de correlações
valor_corr_sig <- round(corr_valor$P, 5) # Matriz com p-valor dos coeficientes
